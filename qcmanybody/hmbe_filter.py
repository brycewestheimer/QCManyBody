"""
HMBE filtering and Schengen term selection.

This module implements the core algorithms for determining which n-body terms
to include in a Hierarchical Many-Body Expansion (HMBE) calculation.
"""

from typing import Dict, Set, Tuple

import numpy as np

from .models.hierarchy import HMBESpecification

__all__ = [
    "passes_hmbe_filter",
    "filter_compute_list",
    "generate_all_subclusters",
    "get_schengen_candidates",
    "select_schengen_terms",
    "compute_distance_metric",
]


def passes_hmbe_filter(fragments: Tuple[int, ...], hmbe_spec: "HMBESpecification") -> bool:
    """
    Determine if an n-body term should be included in base HMBE.

    HMBE Filtering Rule
    -------------------
    An n-body term involving fragments {f_1, f_2, ..., f_n} is INCLUDED if and only if:

    1. n <= T_K (term order constraint: order doesn't exceed finest-tier truncation)
    2. For each tier t from 1 to K-1:
       count of distinct tier-t groups containing any fragment <= T_t

    If ANY condition fails, the term is REJECTED.

    Parameters
    ----------
    fragments : Tuple[int, ...]
        Tuple of 1-indexed fragment IDs (e.g., (1, 2, 5) for a 3-body term)
    hmbe_spec : HMBESpecification
        HMBE specification with truncation orders and hierarchy

    Returns
    -------
    bool
        True if term passes HMBE filter and should be included

    Examples
    --------
    >>> # For (2,3)-HMBE with 4x4 two-tier hierarchy
    >>> # 3-body term from 3 different tier-1 groups: REJECT (3 > T_1=2)
    >>> passes_hmbe_filter((1, 5, 9), hmbe_spec)  # False
    >>> # 3-body term from 2 tier-1 groups, 3 tier-2 groups: KEEP
    >>> passes_hmbe_filter((1, 2, 5), hmbe_spec)  # True
    """
    n = len(fragments)
    hierarchy = hmbe_spec.hierarchy
    truncation_orders = hmbe_spec.truncation_orders

    # Check 1: Order constraint (n <= T_K)
    if n > hmbe_spec.max_nbody:
        return False

    # Check 2: Group count at each tier (tier-1 to tier-(K-1))
    # Note: We check all tiers except the finest (elementary fragments)
    for tier_idx in range(hierarchy.num_tiers - 1):
        count = hierarchy.count_distinct_groups_at_tier(fragments, tier_idx)
        if count > truncation_orders[tier_idx]:
            return False

    return True


def filter_compute_list(
    compute_list: Dict[int, Set[Tuple[Tuple[int, ...], Tuple[int, ...]]]],
    hmbe_spec: "HMBESpecification",
) -> Dict[int, Set[Tuple[Tuple[int, ...], Tuple[int, ...]]]]:
    """
    Filter a compute list to include only HMBE-allowed terms.

    Takes the full MBE compute list generated by build_nbody_compute_list and
    applies the HMBE filtering rule to each term's fragment tuple.

    Parameters
    ----------
    compute_list : Dict[int, Set[Tuple[Tuple[int, ...], Tuple[int, ...]]]]
        Unfiltered compute list from build_nbody_compute_list.
        Keys are n-body levels, values are sets of (fragment_tuple, basis_tuple) pairs.
    hmbe_spec : HMBESpecification
        HMBE specification

    Returns
    -------
    Dict[int, Set[Tuple[Tuple[int, ...], Tuple[int, ...]]]]
        Filtered compute list with only HMBE-allowed terms

    Notes
    -----
    The basis_tuple (second element of each pair) is preserved unchanged.
    Only the fragment_tuple is checked against the HMBE filter.
    """
    filtered = {}

    for nbody, terms in compute_list.items():
        filtered_terms = set()
        for frag_tuple, bas_tuple in terms:
            # Apply HMBE filter to fragment tuple
            if passes_hmbe_filter(frag_tuple, hmbe_spec):
                filtered_terms.add((frag_tuple, bas_tuple))

        # Only add to filtered dict if there are terms at this n-body level
        if filtered_terms:
            filtered[nbody] = filtered_terms

    return filtered


def generate_all_subclusters(
    fragment_tuples: Set[Tuple[int, ...]]
) -> Set[Tuple[int, ...]]:
    """Generate all sub-clusters for a set of fragment tuples.

    Given fragment tuples, returns the closure under the subset operation:
    all tuples plus all their proper sub-clusters.

    Required for mathematical correctness of Möbius inversion in HMBE.

    Parameters
    ----------
    fragment_tuples : Set[Tuple[int, ...]]
        Set of fragment tuples

    Returns
    -------
    Set[Tuple[int, ...]]
        Original tuples plus all their sub-clusters

    Examples
    --------
    >>> generate_all_subclusters({(1,2,3)})
    {(1,), (2,), (3,), (1,2), (1,3), (2,3), (1,2,3)}

    >>> generate_all_subclusters({(1,5,9), (2,3)})
    {(1,), (2,), (3,), (5,), (9,), (1,5), (1,9), (5,9), (1,5,9), (2,3)}
    """
    from itertools import combinations

    result = set(fragment_tuples)

    for frag_tuple in fragment_tuples:
        n = len(frag_tuple)
        # Add all proper sub-clusters
        for sub_size in range(1, n):
            for sub_cluster in combinations(frag_tuple, sub_size):
                result.add(sub_cluster)

    return result


def get_schengen_candidates(
    compute_list: Dict[int, Set[Tuple[Tuple[int, ...], Tuple[int, ...]]]],
    base_hmbe_list: Dict[int, Set[Tuple[Tuple[int, ...], Tuple[int, ...]]]],
    hmbe_spec: "HMBESpecification",
) -> Set[Tuple[int, ...]]:
    """
    Identify candidate Schengen terms (excluded by HMBE but present in base MBE).

    Schengen terms are n-body interactions that fail the HMBE truncation criteria
    but may be important for accuracy, especially at interfaces between hierarchical
    groups. Candidates are terms in the full MBE that are not in the base HMBE.

    Parameters
    ----------
    compute_list : Dict[int, Set[Tuple[Tuple[int, ...], Tuple[int, ...]]]]
        Full MBE compute list (unfiltered)
    base_hmbe_list : Dict[int, Set[Tuple[Tuple[int, ...], Tuple[int, ...]]]]
        Base HMBE compute list (filtered, without Schengen terms)
    hmbe_spec : HMBESpecification
        HMBE specification

    Returns
    -------
    Set[Tuple[int, ...]]
        Set of fragment tuples that are Schengen candidates

    Examples
    --------
    >>> # For (2,3)-HMBE: terms with 3 tier-1 groups are excluded
    >>> # These excluded terms become Schengen candidates
    >>> candidates = get_schengen_candidates(mbe_list, hmbe_list, spec)
    >>> (1, 5, 9) in candidates  # True (3 different tier-1 groups)
    """
    candidates = set()

    for nbody, terms in compute_list.items():
        # Get base HMBE fragment tuples at this n-body level
        base_terms = base_hmbe_list.get(nbody, set())
        base_frags = {frag for frag, _ in base_terms}

        # Find terms in MBE but not in base HMBE
        for frag_tuple, _ in terms:
            if frag_tuple not in base_frags:
                # This term is in MBE but not HMBE - candidate for Schengen
                candidates.add(frag_tuple)

    return candidates


def select_schengen_terms(
    candidates: Set[Tuple[int, ...]],
    molecule,  # qcelemental.Molecule
    hmbe_spec: "HMBESpecification",
) -> Tuple[Set[Tuple[int, ...]], Set[Tuple[int, ...]]]:
    """
    Select top Schengen terms and compute required sub-clusters.

    From the set of candidate Schengen terms (excluded by HMBE truncation),
    select the top fraction based on a distance metric. Terms with smaller
    metric values (closer fragments) are selected first.

    For mathematical correctness of Möbius inversion, ALL sub-clusters of
    selected Schengen terms must be present. This function returns both the
    selected terms AND all necessary sub-clusters.

    Parameters
    ----------
    candidates : Set[Tuple[int, ...]]
        Set of candidate fragment tuples
    molecule : qcelemental.Molecule
        Molecule with fragment definitions and geometry
    hmbe_spec : HMBESpecification
        HMBE specification with Schengen configuration

    Returns
    -------
    Tuple[Set[Tuple[int, ...]], Set[Tuple[int, ...]]]
        (selected_schengen_terms, required_subclusters)
        - selected_schengen_terms: Top fraction by distance metric
        - required_subclusters: All sub-clusters needed for completeness

    Notes
    -----
    If Schengen is disabled in hmbe_spec, returns (empty_set, empty_set).
    Selection is based on center-of-mass distances between fragments.

    Example: If (1,5,9) is selected, required_subclusters includes:
    (1), (5), (9), (1,5), (1,9), (5,9)

    The sub-clusters are REQUIRED for mathematical correctness, not optional.
    """
    if not hmbe_spec.schengen or not hmbe_spec.schengen.enabled:
        return set(), set()

    if not candidates:
        return set(), set()

    # Compute distance metric for each candidate
    distances = {}
    for frag_tuple in candidates:
        dist = compute_distance_metric(frag_tuple, molecule, hmbe_spec.schengen.distance_metric)
        distances[frag_tuple] = dist

    # Select top fraction (smallest distances = closest fragments)
    n_select = max(1, int(len(candidates) * hmbe_spec.schengen.selection_fraction))
    sorted_candidates = sorted(distances.items(), key=lambda x: x[1])
    selected = {frag for frag, _ in sorted_candidates[:n_select]}

    # Generate ALL required sub-clusters for mathematical completeness
    import logging
    from itertools import combinations

    logger = logging.getLogger(__name__)
    required_subclusters = set()

    for frag_tuple in selected:
        n = len(frag_tuple)
        # Add all proper sub-clusters (size 1 to n-1)
        for sub_size in range(1, n):
            for sub_cluster in combinations(frag_tuple, sub_size):
                required_subclusters.add(sub_cluster)

    logger.info(
        f"Selected {len(selected)} Schengen terms, "
        f"requiring {len(required_subclusters)} sub-clusters for completeness"
    )

    return selected, required_subclusters


def compute_distance_metric(
    frag_tuple: Tuple[int, ...],
    molecule,  # qcelemental.Molecule
    metric: str,
) -> float:
    """
    Compute distance metric for a fragment tuple.

    Calculates center-of-mass for each fragment, then applies the specified
    distance metric to all pairwise distances.

    Parameters
    ----------
    frag_tuple : Tuple[int, ...]
        Tuple of 1-indexed fragment IDs
    molecule : qcelemental.Molecule
        Molecule object with geometry and fragment definitions
    metric : str
        One of "R2", "R", "R_inv", "R3_inv", "fmo"

    Returns
    -------
    float
        Distance metric value (smaller = closer fragments)

    Raises
    ------
    ValueError
        If metric is not recognized

    Notes
    -----
    Metrics:
    - R2: Sum of squared distances (recommended, default)
    - R: Sum of distances
    - R_inv: -Sum of inverse distances (negative for proper sorting)
    - R3_inv: -Sum of inverse cube distances
    - fmo: FMO-style with vdW scaling (currently falls back to R2)

    For inverse metrics (R_inv, R3_inv), the result is negated so that
    smaller values still correspond to closer fragments when sorting.
    """
    # Get center of mass for each fragment
    com_positions = []
    for frag_id in frag_tuple:
        frag_atoms = molecule.fragments[frag_id - 1]  # Convert 1-indexed to 0-indexed
        frag_geom = molecule.geometry[frag_atoms, :]
        com = np.mean(frag_geom, axis=0)
        com_positions.append(com)

    # Compute all pairwise distances
    pairwise_dists = []
    for i in range(len(com_positions)):
        for j in range(i + 1, len(com_positions)):
            dist = np.linalg.norm(com_positions[i] - com_positions[j])
            pairwise_dists.append(dist)

    # Apply metric
    if metric == "R2":
        return sum(d**2 for d in pairwise_dists)
    elif metric == "R":
        return sum(pairwise_dists)
    elif metric == "R_inv":
        # Negative so smaller (more negative) = closer
        return -sum(1.0 / d for d in pairwise_dists if d > 1e-10)
    elif metric == "R3_inv":
        return -sum(1.0 / d**3 for d in pairwise_dists if d > 1e-10)
    elif metric == "fmo":
        # TODO: Implement FMO-style scaling with van der Waals radii
        # For now, fall back to R2
        return sum(d**2 for d in pairwise_dists)
    else:
        raise ValueError(f"Unknown distance metric: {metric}. Must be one of: R2, R, R_inv, R3_inv, fmo")
